
在C++标准中，提供了关于【类型层次转换】中的两个关键字【static_cast 和 dynamic_cast】

################### https://www.cnblogs.com/wft1990/p/7126812.html ###############################

一、static_cast关键字（编译时类型检查）
用法：static_cast<type-id>(expression), 该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性；
它主要有如下几种用法：
1> 用于基本数据类型之间的转换，如把int转换为char, 把int转换为enum, 但这种转换的安全性需要开发者自己保证
  （这可以理解为保证数据的精度，即程序员能不能保证自己想要的程序安全）。
   如把int转换为char时，如果char没有足够的比特位来存放int的值（int>127或int<-127时），那么static_cast所做的只是简单的阶段，
   及简单的把int的低8位复制到char的8位中，并直接抛弃高位。
2> 把空指针转换成目标类型的空指针
3> 把任何类型的表达式转换成void类型
4> 用于类层次结构中父类和子类之间指针和引用的转换
4.1>  对于第<4>点，存在两种形式的转换，即上行转换（子类到父类）和下行转换（父类到子类）。
      对于static_cast，上行转换时是安全的，而下行转换时是不安全的，为什么呢？
      因为static_cast的转换是粗暴的，它仅根据类型转换语句中提供的信息（即尖括号中的类型）来进行转换，这种转换方式对于上行转换，由于子类总是包含父类的所有数据成员和函数成员，因此从子类转换到父类的指针对象可以没有任何顾虑的访问其（指父类）的成员。
      而对于下行转换为什么不安全，是因为static_cast只是在编译时进行类型检查，没有运行时的类型检查。

二、dynamic_cast关键字（运行时类型检查）
作为四个内部类型转换操作符之一的dynamic_cast和传统的C风格的强制类型转换有着巨大的差别。除了dynamic_cast以外的转换，其行为的都是在编译器就得以确定的，转换是否成功，并不依赖被转换的对象。
而dynamic_cast则不然。首先dynamic_cast依赖于RTTI信息，其次，在转换时，dynamic_cast会检查转换的source对象是否真的可以转换成target类型，这种检查不是语法上的，而是真实情况的检查。
RTTI相关部分，通常，许多编译器都是通过vtable找到对象的RTTI信息的，这也就意味着，如果基类没有虚方法，也就无法判断一个基类指针变量所指对象的真实类型，这时候，dynamic_cast只能用来做安全的转换，例如从派生类指针转换成基类指针，然而这种转换其实并不需要dynamic_cast参与；
也就是说，dynamic_cast是根据RTTI记载的信息来判断类型转换是否合法的

用法：同static_cast;

dynamic_cast主要用于类层次结构中父类和子类之间的指针和引用的转换，由于具有运行时类型检查，因此，可以保证下行转换的安全性，何为安全性：
    即转换成功就范湖转换后的正确类型指针，如果转换失败，则返回NULL，之所以说static_cast在下行转换时是不安全的，是因为即使转换失败，它也不返回NULL；
    
对于上行转换，dynamic_cast和static_cast是样的；
对于下行转换，说道下行转换，有一点需要了解的是在C++中，一般是可以用父类指针指向一个子类对象，如 【parent* p1 = new Children(); 但这个指针只能访问父类定义的数据成员和函数，这是C++的静态联翩】
    但是一般不定义执行父类对象的子类类型指着你，如 【Children* p1 = new parent(); 这种定义方法不符合生活习惯，在程序设计上也很麻烦。这就解释了也说明了，在上行转换中，static_cast和dynamic效果是一样的，而且都比较安全，因为向上转换的对象一般是指向子类对象的子类指针；而在下行转换中，由于可以定义不同的指向子类对象的父类类型指针，同时static_cast只在编译时进行类型检查，而dynamic_cast是运行时类型检查，则需要视情况而定】

class Base
{
    virtual void fun(){}
};

class Derived:public Base
{
};

由于需要进行向下转换，因此需要定义一个父类类型的指针Base* P，【但是由于子类继承于父类，父类指针可以指向父类对象，也可以指向子类对象，这就是重点所在】。
如果P指向的确实是子类对象，则dynamic_cast和static_cast可以转换成功，如下所示：

Base *p = new Derived();
Derived* pd1 = static_cast<Derived*>(P);
Derived* pd2 = dynamic_cast<Derived*>(P);
以上转换都能成功。

但是，如果P指向的不是子类对象，而是父类对象，如下所示：
Base *p = new Base;
Derived* pd3 = static_cast<Derived*> (P);
Derived *pd4 = dynamic_cast<Derived *>(P);
在以上的转换中，static_cast转换在编译时不会报错，也可以返回一个子类对象指针（假想），但是这样是不安全的，在运行时可能会有问题，因为子类中包含父类中没有的数据和函数成员，这里需要理解转换的字面意思，转换是什么，转换就是把对象从一种类型转换到另一种类型，【如果这时用pd3去访问子类中有，但是父类中没有的成员，就会出现访问越界的错误，导致程序崩溃】。而dynamic_cast由于具有运行时类检查功能，他能检查P的类型，由于上述转换是不合理的，所以它返回NULL。

总结
C++中层次类型转换中无非两种：上行转换和下行转换
对于上行转换：static_cast和dynamic_cast效果一样，都安全；

对于下行转换：必须确定要转换的数据确实是目标类型的数据，即需要注意要转换的父类类型指针是否真的指向子类对象，如果是，static_cast和dynamic_cast都能成功；如果不是，static_cast能返回，但是不安全，可能会出现访问越界错误；而dynamic_cast在运行时类型检查过程中，判定该过程不能转换，则返回NULL；

注意：虚函数对于dynamic_cast转换的租用
    为何使用dynamic_cast转换类型指针时，需要虚函数呢？
    dynamic_cast转换是在运行时进行转换的，运行时转换就需要知道类对象的信息（继承关系等）
    
    如何在运行时获取到这个信息——虚函数表。
    C++对象模型中，对象实例最前面的就是虚函数表指针，通过这个指针可以获取到该类对象的所有虚函数，包括父类的。
    因为派生类会继承基类的虚函数表，所以通过这个虚函数表，我们就可以知道该类对象的父类，在转换的时候就可以用来判断有无继承关系。
    
    所以虚函数表对于正确的基类指针转换为子类指针时非常重要的。


##########  https://blog.csdn.net/u010122607/article/details/49421887 #####
C++是强类型语言
C++继承了C中的隐式和显示转换的方式。但这种转换并不是安全和严格的，加上C++本身对象模型的复杂性，C++增加了四个显示转换的关键字
（static_cast，dynamic_cast，const_static，reinterpret_cast）

static_cast可以做上述隐式转换的事，可以部分的做显式转换的事，也可以进行继承层次的转换。它没有运行时类型检查来保证转换的安全性。它的上行转换时没问题的，但是它的下行转换时不安全的。

dynamic_cast几乎唯一的被用来处理多态。多态分为上行转换和下行转换，上行转换没问题，子类的指针肯定可以转换成父类指针。下行转换就有问题了，如果要把父类的指针A转换成子类的指针B，如果A指向的是子类的对象，这样转没问题。但是，如果A指向的是父类的对象，正确的做法是转换应该为不成功的，因为多态里没有子类的指针指向父类的对象的。所以，在“A指向的是父类的对象，现要把A转成B”这种情况下，如果采用static_cast，不会报错，返回的是转换后的指针，但程序此时是不安全的。如果采用dynamic_cast，它会根据虚函数表找到A指向的是什么对象（这里要求父类必须要有虚函数，否则报错），如果是父类对象，返回NULL，如果是子类对象，返回转换后的指针，程序此时是安全的。所以，这就是dynamic_cast和static_cast最大的区别。
          
const_cast。常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。

reinterpret_cast。这个操作符能够在非相关的类型之间转换。操作结果只是简单的从一个指针到别的指针的值的二进制拷贝。在类型之间指向的内容不做任何类型的检查和转换。




#########################  多态  ###########################
多态：是将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针
多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。
多态：指向基类的指针或引用可以调用派生类的对象，但是只能调用基类的成员函数。如果成员函数被声明为虚函数，则根据对象类型，选择调用相应的函数。

当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针， 动态的调用 属于子类的该函数，这样的函 数调用在编译期间是无法确定的 （调用的子类的虚函数的地址无法给出）。因此， 这样的函数地址是在运行期绑定的（晚绑定）

多态的作用主要是两个：
1. 隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；
2. 接口重用：为了类在继承和派生的时候 ，保证使用家族中任一类的实例的某一属性时的正确调用 。


多态就是多种形态，C++的多态分为静态多态和动态多态
静态多态就是重载，因为在编译器决议确定，所以称为静态多台。在编译时就可以确定函数地址
动态多台就是通过继承重写基类的虚函数实现的多态，因为是在运行时决议确定的，所以称为动态多态。运行时在虚函数表中寻找调用函数的地址。

在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时会根据对象的实际类型来调用相应的函数。
如果对象类型是子类，就调用子类的函数；如果对象类型是父类，就调用父类的函数

