CAS机制

和线程安全有关
CAS和Synchronize的区别？适合什么样的场景，有什么样的优点和缺点？

示例程序：启动两个线程，每个线程中让静态变量count循环累加100次。
最终输出的count结果，由于不是线程安全的，所以最终的自增结果很可能会小于200；
Synchronized：同步锁
加了同步锁之后，count的自增的操作编程了原子性操作，所以最终的输出一定是count=200，代码实现了线程安全；
Synchronized的确保证了线程安全，但是在某些情况下，却并不是一个最优选择；
关于性能问题：Synchronize关键字会让没有得到锁资源的线程进入Blocked状态，而后在争夺到锁资源后恢复为Runnable状态，这个过程中涉及到操作系统用户模式和内核模式的装换，代价比较高；
替代同步锁：使用Atmoic之后，最终的输出结果同样可以保证是200，并且在某些情况下，代码的性能会比Synchronize更好。Atomic操作类的底层，正是利用了CAS机制；

什么是CAS：
CAS是英文单侧Compare And Swap的缩写，翻译过来就是比较并替换
CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。
更新一个变量得到时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。

举例：
在内存地址V当中，存储着值为10的变量，此时线程1想要把变量的值增加1，对线程1来说，旧的预期值A=10，要修改的新值B=11；在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11；之后线程1开始提交更新，首先进行A和地址V的实际值比较，发现A不等于V的实际值，提交失败；线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程称为“自旋”。这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。线程1进行SWAP，把地址V的值替换为B，也就是12。

从思想上来说，Synchronize属于“悲观锁”，悲观的认为程序中的并发情况严重，所以严防死守。CAS属于“乐观锁”，乐观的认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。

这两种机制没有绝对的好与坏，关键看使用场景，在并发量非常高的情况下，反而用同步锁更合适一些。

在许多地方都会用到CAS机制：例如Atomi系列类，以及Lock系列类的底层实现。

CAS的缺点：
CPU开销较大，在并发量比较高的情况下，如果许多线程反腐尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力

不能保证保证代码的原子性，CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronize了。

ABA问题，这是CAS机制最大的问题所在。所谓ABA问题，就是一个变量的值从A改成了B，又从B改成了A。

什么是ABA：
假设内存中有一个值为A的变量，存储在地址V当中，此时有三个线程想要使用CAS的方式更新这个变量值，每个线程的执行时间有略微的偏差。线程1和线程2已经获得当前的值，线程3还未获得当前值；接下来，线程1先一步执行成功，把当前值成功从A更新为B；同时线程2因为某种原因被阻塞住，没有做更新操作；线程3在线程1更新之后，获得了当前值B。再之后，线程2仍然处于阻塞状态，线程3继续执行，成功把当前值从B更新成了A，最后，线程2终于恢复了运行状态，由于阻塞之前已经获得了“当前值”A，并且经过compare检测，内存地址V中的实际值也是A，所以成功吧变量值A更新成了B。这个过程中，线程2获取得到的变量值A是一个旧值，尽管和当前的实际值相同，但内存地址V中的变量已经经历了A->B->A的该表。

这个例子表面看上去没有问题，本来就是将A更新成B，但如果结合实际应用场景，就可以看出它的问题所在：
当我们举一个提款机的例子。假设有一个遵循CAS原理的提款机，小灰有100元存款，要用这个提款机来提款50元。由于提款机硬件出了点小问题，小灰的提款操作被同时提交了两次，开启了两个线程，两个线程都是获取当前值100元，要哦更新成50元。理想情况下应该一个线程更新成功，另一个线程更新失败，小灰的存款只被扣一次。线程1首先执行成功，把余额从100改成50，线程2因为某种原因阻塞了。这时候，小灰的妈妈刚好给小灰汇款50元，线程2仍然是阻塞状态，线程3执行成功，把余额从50改成100。线程2恢复运行，由于阻塞之前已经获得了“当前值”100，并且经过compare检测，此时存款实际值也是100，所以成功把变量值100更新成了50。原本线程2应当提交失败，小灰的正确余额应该保持为100元，结果由于ABA问题提交成功了（举例改编自《java特种兵》）

解决ABA问题的方法也很简单，加个版本号就行。真正做到严谨的CAS机制，我们在Compare阶段不仅要比较期望值A和地址V中的实际值，还要比较变量的版本号是否一致。
假设地址V中存储着变量值A，当前版本号是01。线程1获得了当前值A和版本号01，想要更新为B，但是被阻塞了。这时候，内存地址V中的变量发生了多次改变，版本号提升为03，但是变量值仍然是A。随后线程1恢复运行，进行Compare操作。经过比较，线程1所获得的值和地址V的实际值都是A，但是版本号不相等，所以这一次更新失败。



<<<<<<< HEAD
工程日记：
学习CAS机制的使用场景，当使用share_ptr指针的时候，由于多线程并行，且并发数较大，或提高CPU利用率，为了优化性能，可以改变share_ptr使用策略，改用裸指针会好很多
=======

>>>>>>> a829c000d454aa9846a8978f5bbf648e7f088267











https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653192625&idx=1&sn=cbabbd806e4874e8793332724ca9d454&chksm=8c99f36bbbee7a7d169581dedbe09658d0b0edb62d2cbc9ba4c40f706cb678c7d8c768afb666&scene=21#wechat_redirect

https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653192736&idx=1&sn=24d4054b062e28db9e54c735aafe2407&chksm=8c99f0fabbee79ecfd9198aa89bc78084e9b7db056078982975d8910c12b5d3dd1d16c2509c3&mpshare=1&scene=23&srcid=020903SQqmtv0yiUHSI1DuGd#rd
